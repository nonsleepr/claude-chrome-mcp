# AGENTS.md - Developer Guide

Developer guidance for AI agents working on this codebase.

## Project Overview

MCP server that bridges the Claude Chrome Extension with MCP clients via Chrome native messaging protocol.

## Project Rules

- Use Bun exclusively (no npm)
- No emoji in output or documentation
- No ASCII boxes in output
- PRs and development happen on `main` branch
- `release` branch is the default branch (for installation)

## Essential Commands

```bash
bun run build                # Compile TypeScript to dist/
bun run dev                  # Watch mode
bun test                     # Run all tests
bun test/unit/<name>.test.js # Run specific test

bun install                  # Install dependencies
bun run build && bun link    # Local dev setup

claude-chrome-mcp --install  # Register native host (auto-generates token)
claude-chrome-mcp --status   # Check installation and view token
claude-chrome-mcp --uninstall # Remove installation
```

## Code Style (Critical)

**Imports:**
- MUST use `.js` extension for imports even in `.ts` files:
  ```typescript
  import { ChromeMcpServer } from './server.js';  // Correct
  import { ChromeMcpServer } from './server';     // Wrong
  ```
- ESM syntax only (no `require`)
- Named imports, no default exports

**TypeScript:**
- Strict mode enabled - explicit types required
- Use `unknown` instead of `any`
- Zod schemas for runtime validation

**Naming:**
- Classes/Interfaces: PascalCase
- Functions/Variables: camelCase
- Constants: UPPER_SNAKE_CASE
- Files: kebab-case

**Formatting:**
- 2-space indentation
- Single quotes for strings
- Semicolons required
- JSDoc comments for exported functions/classes

## Architecture

```mermaid
graph LR
    A[MCP Client] -->|HTTP POST /mcp| B[MCP Server]
    B -->|Chrome Protocol| C[Chrome Extension]
    C -->|CDP| D[Browser]
    B -->|stdin/stdout| C
```

**Key files:**
- `src/mcp-server.ts` - HTTP server, registers tools, manages sessions
- `src/chrome-protocol.ts` - Chrome native messaging (length-prefixed JSON on stdin/stdout)
- `src/tools.ts` - 14 browser tools with Zod schemas
- `src/instructions.ts` - Server instructions (~600 words, delivered in MCP initialize)
- `src/install.ts` - Installation (creates wrapper + manifest, detects Bun/Node runtime)

## Server Instructions (src/instructions.ts)

Guidelines for maintaining `SERVER_INSTRUCTIONS`:
- Focus on cross-tool workflows and operational patterns
- Document constraints (60s timeouts, alert/dialog blocking)
- Include critical warnings
- NO tool descriptions (in schemas already)
- NO marketing language
- Test validates: 500+ words, covers GIF/console/alerts/tabs/timeouts

## How It Works

```mermaid
sequenceDiagram
    participant User
    participant Install as Install Script
    participant Chrome
    participant Wrapper
    participant MCP as MCP Server
    participant Client as MCP Client
    
    User->>Install: claude-chrome-mcp --install
    Install->>Install: Create wrapper + manifest
    User->>Chrome: Restart browser
    Chrome->>Wrapper: Launch on extension connect
    Wrapper->>MCP: Start native host
    MCP->>MCP: HTTP server :3456/mcp
    Client->>MCP: Tool request
    MCP->>Chrome: Via stdin/stdout
    Chrome->>Client: Tool response
```

**Auto-initialization:** Tab groups created automatically by extension when `tabs_context` called

## Adding a Tool

1. Add to `src/tools.ts`:
   ```typescript
   export const myTool: ToolDefinition = {
     name: 'my_tool',
     description: 'Brief description',
     inputSchema: z.object({
       param: z.string().describe('Parameter description'),
     }),
   };
   ```
2. Add to `allTools` array
3. Rebuild: `bun run build`

## Testing

**Unit tests** use Node.js built-in `assert`:
- `test/unit/auth-cors.test.js` - Authentication/CORS middleware
- `test/unit/runtime-detection.test.js` - Bun/Node detection
- `test/unit/instructions.test.js` - Validates server instructions

**Manual integration testing** requires Chrome extension installed

## Common Issues

**Build errors:**
- Clean: `rm -rf dist/ && bun run build`
- Check imports use `.js` extension
- Verify all types explicit (strict mode)

**Runtime errors:**
- "Port in use": `lsof -i :3456` (Linux/Mac) or `netstat -ano | findstr :3456` (Windows)
- "Connection timeout": Chrome extension not connected
- Tool timeout: 60s limit, break into smaller operations

**Installation:**
- Run `claude-chrome-mcp --status` to verify
- Restart Chrome completely after install/uninstall
- Wrapper must be executable (Unix)

## Security

- HTTP binds to 127.0.0.1 only
- Bearer token auth (auto-generated by default)
- Native messaging manifest restricts to specific extension ID
- Configurable CORS origins

## Wire Protocol

Chrome Native Messaging: `[4 bytes length (little-endian)] [N bytes JSON (UTF-8)]`

## Build and Release Process

### Repository Strategy

This project uses GitHub as the primary public repository. Development workflows may vary based on contributor preferences.

### Branch Strategy

- `main`: Development branch (no `dist/` committed)
- `release`: Default branch for installation (contains `dist/`)

Users install from the `release` branch:
```bash
bun install -g git+https://github.com/USER/REPO.git
```

### Automated Release Workflow

The release process is automated via a bun script that handles version bumping and tagging.

#### Quick Release

```bash
# Interactive release (recommended)
bun run release

# Dry run to preview changes
bun run release:dry
```

### Release Process Details

The `bun run release` command performs the following steps:

1. **Pre-release checks:**
   - Verify git working directory is clean
   - Confirm on main branch (or prompt to continue)
   - Run tests: `bun test`
   - Build project: `bun run build`

2. **Version bump:**
   - Prompt for bump type (patch/minor/major/custom)
   - Update `package.json` with new version
   - Commit to main branch

3. **Merge to release:**
   - Checkout `release` branch
   - Merge `main` into `release`
   - Force-add `dist/` (ignored by `.gitignore`)
   - Commit dist changes
   - Create annotated git tag: `vX.Y.Z`
   - Return to main branch

4. **Push manually:**
   ```bash
   git push origin main           # Push main branch
   git push origin release        # Push release branch
   git push origin vX.Y.Z         # Push the tag
   ```

5. **Create release (optional):**
   - GitHub: `gh release create vX.Y.Z --generate-notes`
   - GitLab/Gitea: Create via web UI

### Installation

Users install directly from the repository:

```bash
# Install latest from repository
bun install -g git+https://github.com/USER/REPO.git

# Install specific version tag
bun install -g git+https://github.com/USER/REPO.git#v0.1.0
```

**Note:** Installation requires `devDependencies` (TypeScript) to build. Users must have `bun` or `node` with TypeScript available.

### Release Checklist

When running `bun run release`, the script handles most of this automatically:

- [ ] Clean git working directory
- [ ] On main branch
- [ ] Tests pass
- [ ] Build succeeds
- [ ] Version bumped in package.json
- [ ] Changes committed to main
- [ ] Main merged into release
- [ ] dist/ committed to release
- [ ] Git tag created
- [ ] Push commit and tag to remote (manual)
- [ ] Create release on hosting platform (optional)

### Manual Release (Fallback)

If the automated script fails, you can release manually:

```bash
# 1. Update version in package.json manually
NEW_VERSION="0.1.1"  # Set your version

# 2. Commit and tag
git add package.json
git commit -m "Release v$NEW_VERSION"
git tag -a v$NEW_VERSION -m "Release v$NEW_VERSION"

# 3. Push to remote
git push <remote> <branch>
git push <remote> v$NEW_VERSION

# 4. Create release (optional)
# GitHub: gh release create v$NEW_VERSION --generate-notes
# GitLab/Gitea: Use web UI
```

### Troubleshooting Releases

**Release creation on hosting platform:**
- GitHub: Ensure `gh` CLI is installed and authenticated: `gh auth status`
- GitLab/Gitea: Use the web UI to create releases from tags
